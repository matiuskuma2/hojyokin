#!/usr/bin/env node
/**
 * snapshot_production_schema.mjs
 * 
 * 本番D1スキーマのスナップショットを取得してGitに保存する
 * 
 * 使用方法:
 *   npx wrangler d1 execute DB --remote --command="SELECT sql FROM sqlite_master WHERE type IN ('table', 'index') AND sql IS NOT NULL ORDER BY type, name" --json > docs/schema_snapshot.json
 *   
 *   または本スクリプトで整形:
 *   node tools/snapshot_production_schema.mjs
 * 
 * 出力:
 *   docs/schema_snapshot_YYYY-MM-DD.sql - CREATE文一覧
 *   docs/schema_tables.json - テーブル情報（PRAGMA table_info）
 *   docs/schema_indexes.json - インデックス情報
 */

import { execSync } from 'child_process';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';

const DOCS_DIR = join(process.cwd(), 'docs');
const TODAY = new Date().toISOString().split('T')[0];

// docs ディレクトリがなければ作成
if (!existsSync(DOCS_DIR)) {
  mkdirSync(DOCS_DIR, { recursive: true });
}

/**
 * wrangler d1 execute を実行して結果を取得
 */
function executeD1(command, remote = true) {
  const remoteFlag = remote ? '--remote' : '--local';
  const cmd = `npx wrangler d1 execute DB ${remoteFlag} --command="${command}" --json`;
  
  try {
    const result = execSync(cmd, { 
      encoding: 'utf-8',
      maxBuffer: 50 * 1024 * 1024 // 50MB
    });
    return JSON.parse(result);
  } catch (error) {
    console.error(`Error executing: ${cmd}`);
    console.error(error.message);
    return null;
  }
}

/**
 * 全テーブルのCREATE文を取得
 */
function getSchemaSQL(remote = true) {
  console.log('Fetching schema SQL...');
  const result = executeD1(
    "SELECT type, name, sql FROM sqlite_master WHERE type IN ('table', 'index') AND sql IS NOT NULL ORDER BY type, name",
    remote
  );
  
  if (!result || !result[0]?.results) {
    console.error('Failed to fetch schema');
    return null;
  }
  
  return result[0].results;
}

/**
 * 全テーブルのカラム情報を取得
 */
async function getTableInfo(tableName, remote = true) {
  const result = executeD1(`PRAGMA table_info(${tableName})`, remote);
  if (!result || !result[0]?.results) return [];
  return result[0].results;
}

/**
 * 全テーブルのインデックス情報を取得
 */
function getIndexList(tableName, remote = true) {
  const result = executeD1(`PRAGMA index_list(${tableName})`, remote);
  if (!result || !result[0]?.results) return [];
  return result[0].results;
}

/**
 * テーブル名一覧を取得
 */
function getTableNames(remote = true) {
  const result = executeD1(
    "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' ORDER BY name",
    remote
  );
  if (!result || !result[0]?.results) return [];
  return result[0].results.map(r => r.name);
}

/**
 * メイン処理
 */
async function main() {
  const args = process.argv.slice(2);
  const remote = !args.includes('--local');
  
  console.log(`Mode: ${remote ? 'REMOTE (production)' : 'LOCAL (development)'}`);
  console.log('');
  
  // 1. スキーマSQL取得
  const schemaRows = getSchemaSQL(remote);
  if (!schemaRows) {
    process.exit(1);
  }
  
  // 2. SQL ファイル生成
  const tables = schemaRows.filter(r => r.type === 'table');
  const indexes = schemaRows.filter(r => r.type === 'index');
  
  let sqlContent = `-- =====================================================\n`;
  sqlContent += `-- Production Schema Snapshot: ${TODAY}\n`;
  sqlContent += `-- Generated by: tools/snapshot_production_schema.mjs\n`;
  sqlContent += `-- Mode: ${remote ? 'REMOTE' : 'LOCAL'}\n`;
  sqlContent += `-- =====================================================\n\n`;
  
  sqlContent += `-- =====================================================\n`;
  sqlContent += `-- TABLES (${tables.length})\n`;
  sqlContent += `-- =====================================================\n\n`;
  
  for (const table of tables) {
    sqlContent += `-- ${table.name}\n`;
    sqlContent += `${table.sql};\n\n`;
  }
  
  sqlContent += `-- =====================================================\n`;
  sqlContent += `-- INDEXES (${indexes.length})\n`;
  sqlContent += `-- =====================================================\n\n`;
  
  for (const idx of indexes) {
    sqlContent += `${idx.sql};\n`;
  }
  
  const sqlPath = join(DOCS_DIR, `schema_snapshot_${TODAY}.sql`);
  writeFileSync(sqlPath, sqlContent);
  console.log(`Written: ${sqlPath}`);
  
  // 3. テーブル情報JSON生成
  const tableNames = getTableNames(remote);
  const tableInfoMap = {};
  
  console.log(`\nFetching table info for ${tableNames.length} tables...`);
  for (const name of tableNames) {
    tableInfoMap[name] = {
      columns: await getTableInfo(name, remote),
      indexes: getIndexList(name, remote)
    };
  }
  
  const tableInfoPath = join(DOCS_DIR, `schema_tables_${TODAY}.json`);
  writeFileSync(tableInfoPath, JSON.stringify(tableInfoMap, null, 2));
  console.log(`Written: ${tableInfoPath}`);
  
  // 4. サマリー出力
  console.log('\n--- Summary ---');
  console.log(`Tables: ${tables.length}`);
  console.log(`Indexes: ${indexes.length}`);
  console.log('');
  console.log('Tables:');
  for (const t of tables) {
    const colCount = tableInfoMap[t.name]?.columns?.length || '?';
    console.log(`  - ${t.name} (${colCount} columns)`);
  }
  
  // 5. Latest シンボリックリンク用のコピーも作成
  const latestSqlPath = join(DOCS_DIR, 'schema_snapshot_latest.sql');
  const latestJsonPath = join(DOCS_DIR, 'schema_tables_latest.json');
  writeFileSync(latestSqlPath, sqlContent);
  writeFileSync(latestJsonPath, JSON.stringify(tableInfoMap, null, 2));
  console.log(`\nLatest copies created.`);
}

main().catch(console.error);
